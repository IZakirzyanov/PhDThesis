%!TEX root = ../dissertation.tex

\chapter{Обзор предметной области} 
\label{sec:review}

\section{Задача выполнимости}
\label{sec:review:sat}

\section{Детерминированные конечные автоматы} 
\label{sec:review:dfa-def}

\emph{Алфавитом} $\Sigma$ называется некоторое конечное непустое множество символов.
\emph{Размером алфавита} $\Sigma$ называется число его символов~{---} $L = \abs{\Sigma}$.
В данной диссертации в основном будет рассматривать бинарный алфавит $\Sigma = \mathbb{B} = \{0, 1\}$.
\emph{Словом} (\emph{строкой}, \emph{цепочкой}) $\omega$ называется конечная последовательность символов некоторого алфавита. 
\emph{Длиной слова} называется число символов в нем, обозначается как $\abs{\omega}$.
Множество слов длины $k$ над алфавитом $\Sigma$ обозначается как $\Sigma^{k}$.
\emph{Пустой строкой} называется слово, не содержащее ни одного символа.
Такая строка, обозначаемая как $\varepsilon$, имеет нулевую длиной и может рассматриваться как слово над любым алфавитом~{---} $\Sigma^{0}=\{\varepsilon\}$.
Множество всех возможных слов, составленных из символов некоторого алфавита $\Sigma$, является его замыканием:
$$\Sigma^{*} = \bigcup_{k=0}^{\infty}\Sigma^{k}.$$
Подмножество множества всех слов над алфавитом $\Sigma$ называется \emph{языком}~--- $\mathcal{L} \subset \Sigma^{*}$.

\emph{Детерминированным конечным автоматом} (ДКА) называется пятерка $\mathcal{D} = \left(D,\Sigma,\delta,d_{1},D^{+}\right)$, где $D$~{---} конечное множество состояний, $\Sigma$~{---} алфавит входных символов, $\delta:D \times \Sigma \rightarrow D$~{---} \emph{функция переходов}, $d_{1}$~{---} \emph{стартовое} (\emph{начальное}) состояние, $D^{+} \subset D$~{---} множество \emph{допускающих} (\emph{принимающих}) состояний. 
В неявном виде также задано множество \emph{недопускающих} (\emph{отвергающих}) состояний $D^{-} = D \setminus D^{+}$.

Индуктивно определим вспомогательную \emph{расширенную функцию переходов} $\hat{\delta}: D \times \Sigma^{*} \rightarrow D$:
\begin{enumerate}
  \item для любого состояния $d_{i}$ верно, что переход по пустой строке не осуществляется~{---} $\hat{\delta}\left(d_{i},\varepsilon\right) = d_{i}$;
  \item для любого состояния $d_{i}$ верно, что переход по строке $\pi = \pi'c$, где $\pi,\pi' \in \Sigma^{*}$, $c \in \Sigma$, может быть определен следующим образом $\hat{\delta}\left(d_{i}, \pi\right) = \delta\left(\hat{\delta}\left(d_{i}, \pi'\right), c\right)$.
\end{enumerate}
Говорят, что ДКА $\mathcal{D}$ \emph{допускает} (\emph{принимает}) слово $\omega$, если $\hat{\delta}\left(d_{1}, \omega\right) \in D^{+}$. 
Иначе, если $\hat{\delta}\left(d_{1}, \omega\right) \in D^{-}$, говорят, что ДКА $\mathcal{D}$ \emph{не допускает} (\emph{отвергает}) слово $\omega$. 
Множество всех слов, допускаемых автоматом $\mathcal{D}$, называется языком автомата $\mathcal{D}$: $\mathcal{L}\left(D\right) = \{\omega \mid \hat{\delta}\left(d_{1}, \omega \right)\}$.

\inote{рассказать про полноту и детерминированность}

%----------------------------------------------------------------------------------------

\section{Задача генерации детерминированных конечных автоматов} 
\label{sec:review:dfa-inf}

\inote{Добавить вступление про то, зачем и почему нужно их генерировать. И прочую мишуру}

\inote{Тут описать задачу --- про примеры поведения, соответствие и прочее}

%----------------------------------------------------------------------------------------

\section{Генерация детерминированных конечных автоматов при помощи сведения к задаче выполнимости} 
\label{sec:review:sat-dfa-inf} 

\inote{Здесь описание метода Сикко-Вервера.}

\subsection{Расширенное префиксное дерево}
\label{sec:review:sat-dfa-inf:apta}
Первым шагом рассматриваемого подхода является построение \emph{расширенного префиксного дерева} (augmented prefix tree acceptor~{---} APTA) по имеющимся множествам примеров поведения $S_{+}$ и $S_{-}$. 
Расширенное префиксное дерево~--- это древовидная структура данных, основанная на обычном префиксном дереве (бор, нагруженное дерево, prefix tree, trie), отличающаяся от нее метками вершин.
Более формально, префиксным деревом называется шестерка $\mathcal{T} = \left(T,\Sigma,\tau,t_{1},T^{+}, T^{-}\right)$, где $T$~{---} конечное множество вершин, $\Sigma$~{---} алфавит входных символов, $\tau: T \times \Sigma \pto T$~{---} \emph{функция переходов}, $t_{1}$~{---} \emph{корневая} вершина (\emph{корень}), $T^{+} \subset T$~{---} множество \emph{допускающих} (\emph{принимающих}) вершин, $T^{-} \subset T$~{---} множество \emph{не допускающих} (\emph{отвергающих}) вершин.
В отличие от функции переходов в ДКА, функция переходов $\tau$ является частичной. 
Также, в префиксном дереве $T^{+} \cup T^{-} \subset T$, то есть некоторые вершины могут не являться ни принимающими, ни отвергающими. 

Расширенное префиксное дерево для множеств примеров поведения $S_{+}$ и $S_{-}$ строится как обычное префиксное дерево, но терминальные вершины для каждого слова помечаются соответствующей меткой. Вершины, в которых не заканчивается ни один из примеров поведения, остаются непомеченными. Пример расширенного префиксного дерева приведен на \inote{рисунке}.

\subsection{Пропозициональное кодирование} \label{sec:review:sat-dfa-inf:hv-encoding}

\inote{вступление какое-то про кодирование}

Для того, чтобы закодировать задачу генерации ДКА минимального размера на языке SAT, авторами~\cite{heule-icgi10} было предложено ввести три типа булевых переменных \inote{где-то указать, что $\left[N\right] = {1,2,\ldots,N}$}:
\begin{enumerate}
  \item переменные соответствия $\{x_{v,i}\}_{v \in T, i \in \left[M\right]}$, которые истинны тогда и только тогда, когда вершина $t_{v}$ в расширенном префиксном дереве $\mathcal{T}$ соответствует состоянию $d_{i}$ в автомате $\mathcal{D}$;
  \item переменные переходов $\{y_{i,l,j}\}_{i,j \in \left[M\right],l \in \Sigma}$, которые истинны тогда и только тогда, когда в автомате $\mathcal{D}$ существует переход из состояния $d_{i}$ в состояние $d_{j}$ по символу $l$;
  \item переменные допуска $\{z_{i}\}_{i \in \left[M\right]}$, которые истинны тогда и только тогда, когда в автомате $\mathcal{D}$ состояние $d_{i}$ является допускающим.
\end{enumerate}

Используя вышеопределенные переменные, сведение, предложенное авторами~\cite{heule-icgi10}, можно представить с помощью следующих множеств дизъюнктов.

\inote{возможно надо сформулировать на языке логики первого порядка, а потом уже привести к дизъюнктам}

\inote{ОПА. Только что осознал, что так как половина из этих дизъюнктов является избыточными, необязательными, то они тоже служат для сокращения пространства поиска, а значит их надо, видимо, отдельно рассматривать. У Сикко и Хойла это называлось прямое сведение и какое-то там еще.}

\begin{enumerate}
  \item $\left(x_{v,1} \vee x_{v,2} \vee \ldots \vee x_{v,M}\right)$ для $v \in \left[N\right]$~{---} каждой вершине $t_{v}$ расширенного префиксного дерева $\mathcal{T} $ в соответствие ставится как минимум одно состояние автомата $\mathcal{D}$.
  %
  \item $\left(\neg x_{v,i} \vee \neg x_{v,j}\right)$ для $v \in \left[N\right]; i,j \in \left[M\right]; i < j$~{---} каждой вершине $t_{v}$ расширенного префиксного дерева $\mathcal{T} $ в соответствие ставится не более одного состояния автомата $\mathcal{D}$.
  %
  \item $\left(y_{i,l,1} \vee y_{i,l,2} \vee \ldots \vee y_{i,l,M}\right)$ для $i \in \left[M\right]; l \in \Sigma$~{---} из каждого состояния $d_{i}$ автомата $\mathcal{D}$ существует как минимум один переход по каждому символу $l$ алфавита $\Sigma$, иными словами, ДКА $\mathcal{D}$ полон.
  %
  \item $\left(\neg y_{i,l,j} \vee \neg y_{i,l,h}\right)$ для $i,j,h \in \left[M\right]; j < h; l \in \Sigma$~{---} из каждого состояния $d_{i}$ автомата $\mathcal{D}$ существует не более одного перехода по каждому символу $l$ алфавита $\Sigma$, иными словами, ДКА $\mathcal{D}$ детерминирован.
  %
  \item $\left(\neg x_{v,i} \vee z_{i}\right)$ для $t_{v} \in T^{+}; i \in \left[M\right]$~{---} если принимающей вершине $t_{v}$ расширенного префиксного дерева $\mathcal{T}$ в соответствие ставится состояние $d_{i}$ автомата $\mathcal{D}$, то это состояние также должно быть принимающим.
  %
  \item $\left(\neg x_{v,i} \vee \neg z_{i}\right)$ для $t_{v} \in T^{-}; i \in \left[M\right]$~{---} если отвергающей вершине $t_{v}$ расширенного префиксного дерева $\mathcal{T}$ в соответствие ставится состояние $d_{i}$ автомата $\mathcal{D}$, то это состояние также должно быть отвергающим.
  %
  \item $\left(\neg x_{v,i} \vee \neg x_{w,j} \vee y_{i,l,j}\right)$ для $v,w \in \left[N\right]; i,j \in \left[M\right];l \in \Sigma; \tau\left(t_{v},l) = t_{w}\right)$~{---} если вершине $t_{v}$ расширенного префиксного дерева $\mathcal{T} $ в соответствие ставится состояние $d_{i}$ автомата $\mathcal{D}$, вершине $t_{w}$~{---} состояние $d_{j}$ и в префиксном дереве $\mathcal{T}$ существует переход из вершины $t_{v}$ в вершину $t_{w}$ по символу $l$, то в автомате $\mathcal{D}$ должен быть переход из состояния $d_{i}$ в состояние $d_{j}$ по символу $l$.
  %
  \item $\left(\neg x_{v,i} \vee \neg y_{i,l,j} \vee x_{w,j}\right)$ для $v,w \in \left[N\right]; i,j \in \left[M\right];l \in \Sigma; \tau\left(t_{v},l) = t_{w}\right)$~{---} если вершине $t_{v}$ расширенного префиксного дерева $\mathcal{T} $ в соответствие ставится состояние $d_{i}$ автомата $\mathcal{D}$, и в префиксном дереве $\mathcal{T}$ существует переход из вершины $t_{v}$ в вершину $t_{w}$ по символу $l$ и в автомате $\mathcal{D}$ существует переход из состояния $d_{i}$ в состояние $d_{j}$ по символу $l$, вершине $t_{w}$ дерева $\mathcal{T}$ должно ставиться в соответствие состояние $d_{j}$.
  %
  \item $x_{1,1}$~{---} корню $t_{1}$ расширенного префиксного дерева $\mathcal{T} $ в соответствие ставится начальное состояние $d_{1}$ автомата $\mathcal{D}$.
\end{enumerate}

Все представленные выше наборы дизъюнктов могут быть объединены с помощью конкатенации в одну большую булеву формулу. Всего в такой формуле будет $\mathcal{O}(M^{3} + N \times M^{2})$ дизъюнктов и для их кодирования будет использовано $\mathcal{O}(M^2 + N \times M)$ переменных.

%----------------------------------------------------------------------------------------

\section{Подходы к сокращению пространства поиска при генерации детерминированных конечных автоматов}
\label{sec:review:sym-breaking}

\inote{рассказать про пространство поиска в принципе}

\subsection{Граф несовместимости}
\label{sec:review:sym-breaking:ig}

Помимо пропозиционального кодирования, описанного в разделе~\ref{sec:review:sat-dfa-inf:hv-encoding}, авторы~\cite{heule-icgi10} предложили использовать вспомогательную структуру данных, названную ими \emph{графом совместимости} (\emph{consistency graph}).
Несмотря на оригинальное название, как будет видно далее, данная структура данных должна скорее называться \emph{графом несовместимости} (\emph{inconsistency graph}).
В данной диссертации предлагается использовать последнее название.

В основе данной идеи лежит подход со слияниями состояний.
Две вершины $t_{v}$ и $t_{w}$ расширенного префиксного дерева можно слить (объединить, merge) в одну вершину $t_{v'}$, объединив множества исходящих из них переходов.
Если в результате данной операции в префиксном дереве возникла недетерминированность, то есть из вершины $t_{v'}$ теперь исходят два различных перехода по одному и тому же символу в различные вершины $t_{q}$ и $t_{r}$, то от нее можно избавиться объединив вершины $t_{q}$ и $t_{r}$ в одну вершину $t_{q'}$. 
Рекурсивно продолжая данный процесс, можно избавиться от всех случаев недетерминированности в префиксном дереве.
Важным фактом является то, что если в процессе избавления от недетерминированности в какой-то момент приходится объединить принимающую вершину с отвергающей, то изначальное слияние вершин $t_{v}$ и $t_{w}$ невозможно.
В таком случае говорят, что вершины $t_{v}$ и $t_{w}$ \emph{несовместимы} (\emph{inconsistent}).
Данную информацию можно использовать для помощи программному средству для решения задачи SAT.

Более формально, по имеющемуся расширенному префиксному дереву $\mathcal{T} = \left(T,\Sigma,\tau,t_{1},T^{+},T^{-}\right)$ предлагается построить граф $\mathcal{I} = \left(V, E\right)$ такой, что его множество вершин $V$ совпадает со множеством вершин $\mathcal{T}$ префиксного дерева $\mathcal{T}$, а множество ребер $E$ определяется следующим образом. 
Две вершины в графе $\mathcal{I}$ соединены ребром тогда и только тогда, когда их объединение и последующее избавление от недетерминированности приводит к несовместимости. 

Так как искомый ДКА $\mathcal{D}$ соответствует префиксному дереву $\mathcal{T}$, то если две вершины $t_{v}$ и $t_{w}$ смежны в графе несовместимости $\mathcal{I}$, то они не могут соответствовать одному и тому же состоянию $d_{i}$ автомата $\mathcal{D}$.
Данное свойство может быть выражено с помощью переменных $x_{v,i}$ в виде следующего множества дизъюнктов~{---} $\left(\neg x_{v,i} \vee \neg x_{w,i}\right)$ для $v,w \in \left[N\right]; \left(v,w\right) \in E; i \in \left[M\right]$.
Такие дизъюнкты необязательны, но их добавление к основной булевой формуле помогает значительно сократить пространство поиска программного средства для решения SAT. 
Однако, надо заметить, что в общем случае таких дизъюнктов будет $\mathcal{O}\left(N^{2} \times M\right)$, что на порядок относительно $N$ увеличивает размер формул. 
Использование графа несовместимости в таком виде для построения больших автоматов по большому множеству примеров поведения нецелесообразно. 
В разделе \inote{ДОБАВИТЬ ССЫЛКУ} будут предложены несколько способов использования только части графа несовместимости, что не увеличивает размер формулы, но позволяет дополнительно сократить пространство поиска.

\subsection{Изоморфные автоматы}
\label{sec:review:sym-breaking:isomorphic-automata}

\inote{рассказать про изоморфные автоматы и симметрию. Отметить, что их факториал}

\subsection{Большая клика}
\label{sec:review:sym-breaking:large-clique}

Как было сказано в предыдущем разделе, при отсутствии каких-либо ограничений на нумерацию состояний автомата, существует $M!$ изоморфных автоматов.
Авторы~\cite{heule-icgi10} предложили свой способ нарушения симметрии, позволяющий сократить число рассматриваемых изоморфных автоматов.
Так как в графе несовместимости смежные вершины по определению не могут соответствовать одному состоянию в искомом ДКА, то все вершины в некоторой клике (клика~{---} полный граф, граф в котором каждая вершина соединена ребром со всеми остальными) \inote{ссылку на статью про клики} такого графа будут соответствовать различным состояниям автомата.
Учитывая, что итоговая нумерация состояний автомата не важна, можно, не уменьшая общности, зафиксировать номера вершин такой клики, что и было предложено в рассматриваемой статье.

Однако, задача поиска клики максимального размера в некотором графе является NP-полной \inote{ссылку}.
Поэтому авторами было предложено найти клику большого, но не обязательно максимального размера.
Сделать это можно с помощью следующего эвристического подхода.
В графе ищется вершина максимальной степени, которая будет входить в искомую большую клику.
Затем ищется смежная ей вершина максимальной степени и добавляется в клику.
Затем ищется вершина максимальной степени смежная обеим предыдущим и также добавляется в клику. 
Повторяя данный процесс, пока есть возможность существуют вершины смежные всем уже добавленным в клику.

Таким образом, если размер найденной клики равен $C$, то вместо $M!$ изоморфных автоматов будут рассмотрены $(M - C)!$ изоморфных автомата.
Учитывая скорость роста факториала, разница между $M!$ и $(M - C)!$ может быть значительной, однако в общем случае число рассматриваемых изоморфных автоматов все еще остается факториальным относительно размера автомата.
Помимо вышеуказанного недостатка, данный подход требует обязательного построения полного графа несовместимости, что, как было/будет \inote{???} рассмотрено ранее/далее, далеко не всегда является возможным.


\subsection{Предикаты нарушения симметрии на основе алгоритма обхода графа в ширину}
\label{sec:review:sym-breaking:bfs-based}

Идеальным нарушением симметрии является ситуация, когда для каждого класса эквивалентности относительно симметрии остается единственный представитель. 
Для задачи генерации ДКА~{---} когда для каждого класса эквивалентности по изоморфизму остается единственный представитель.
Автором данной диссертации совместно с научным руководитем \inote{тут понять как статью с первой латы обыгрывать} в~\cite{zakirzyanov2015LATA} были разработаны предикаты нарушения симметрии на основе алгоритма обхода графа в ширину, которые позволяют добиться идеального нарушения симметрии

Идея предложенного подхода состоит в том, чтобы зафиксировать нумерацию состояний в порядке \emph{обхода в ширину} (\emph{breadth-first search}~{---} BFS) данного автомата.
\inote{наверное, нужно рассказать, что за BFS такой. описание+псевдокод}
Для того, чтобы сделать обход в ширину уникальным, необходимо зафиксировать некоторый порядок на входных символах переходов, например, лексикографический. 
Будем называть ДКА \emph{BFS-пронумерованным}, если нумерация его состояний соответствует порядку обхода его состояний в ширину.
Тогда в каждом классе эквивалентности по изоморфизму будет ровно один BFS-пронумерованный представитель.

Другими словами, если рассмотреть дерево BFS, построенное для некоторого ДКА, расположив при этом детей в соответствии с выбранным порядком на символах переходов, тогда номера состояний:
\begin{itemize}
  \item должны быть различными числами от $1$ до $M$;
  \item на одной глубине должны увеличиваться слева направо (\emph{порядок по уровню});
  \item должны увеличиваться сверху вниз (\emph{порядок по глубине}).
\end{itemize}
Пример BFS-пронумерованного автомата и построенного для него дерева BFS приведен на рисунке \inote{рисунок}.

Если закодировать требование к автомату, чтобы он был BFS-пронумерованным, в виде булевых предикатов и добавить к имеющейся формуле, предложенной в~\cite{heule-icgi10}, то программное средство для решения SAT будет искать автоматы, удовлетворяющие заданным примерам поведения, пронумерованные в порядке BFS.
Для того, чтобы закодировать данное требование, было предложено ввести три новых типа булевых переменных:

\begin{enumerate}
  \item переменные родителей $\{p_{j,i}\}_{1 \leq i < j \leq M}$, которые истинны тогда и только тогда, когда состояние $d_i$ является родителем состояния $d_j$ в BFS дереве автомата $\mathcal{D}$;
  \item переменные переходов $\{t_{i,j}\}_{1 \leq i < j \leq M}$, которые истинны тогда и только тогда, когда в автомате $\mathcal{D}$ существует переход из состояния $d_{i}$ в состояние $d_{j}$;
  \item переменные минимального символа $\{m_{i,l,j}\}_{1 \leq i < j \leq M;l \in \Sigma}$, которые истинны тогда и только тогда, когда в автомате $\mathcal{D}$ из состояния $d_{i}$ в состояние $d_{j}$ существует переход по символу $l$, но не существует переходов по меньшим (согласно выбранному порядку на символах) символам.
  Данные переменные используются только в случае небинарного алфавита.
\end{enumerate}

Используя данные переменные, можно закодировать свойство BFS-пронумерованности автомата с помощью следующих множеств дизъюнктов.

\begin{enumerate}
  \item $\left(t_{i,j} \leftrightarrow y_{i,l_{1},j} \vee y_{i,l_{2},j} \vee \ldots \vee y_{i,l_{L},j} \right)$ для $1 \leq i < j \leq M; l_{k} \in \Sigma$~--- в автомате $\mathcal{D}$ переход из состояния $d_{i}$ в состояние $d_{j}$ существует тогда и только тогда, когду существует переход из состояния $d_{i}$ в состояние $d_{j}$ хотя бы по одному из символов алфавита $\Sigma$.
  
  \item $\left(p_{j,i} \leftrightarrow t_{i,j} \wedge \neg t_{i - 1,j} \wedge \neg t_{i - 2, j} \wedge \ldots \wedge \neg t_{1,j}\right)$ для $1 \leq i < j \leq M$~{---} состояние $d_{i}$ автомата $\mathcal{D}$ является родителем состояния $d_{j}$ в BFS дереве, если из состояния $d_{i}$ существует переход в состояние $d_{j}$, а из состояний с меньшим номером такого перехода не существует.
  
  \item $\left(p_{j,1} \vee p_{j,2} \vee \ldots \vee p_{j,j - 1}\right)$ для $2 \leq j \leq M$~{---} у каждого состояния $d_{j}$ автомата $\mathcal{D}$, кроме стартового, родитель в BFS дереве должен иметь меньший номер. 
  Данные дизъюнкты позволяют закодировать порядок по глубине в поддереве.

  \item $\left(p_{j,i} \rightarrow \neg p_{j + 1, k}\right)$ для $1 \leq k < i < j \leq M$~{---} если состояние $d_{i}$ является родителем в дереве BFS состояния $d_{j}$, то у состояния с б\emph{о}льшим номером $d_{j + 1}$ родитель не может иметь номер меньший, чем $i$. 
  Данные дизъюнкты позволяют задать порядок по уровню для детей различных родителей, а также порядок по глубине в разных поддеревьях.
  
  \item $\left(p_{j,i} \wedge p_{j + 1, i} \rightarrow y_{i,l_{1},j}\right)$ для $1 \leq i < j \leq M;\Sigma=\{l_{1},l_{2}\}$~{---} если состояние $d_i$ является родителем в дереве BFS двух состояний $d_{j}$ и $d_{j+1}$ и алфавит бинарный, то переход из состояния $d_{i}$ в $d_{j}$ должен быть по меньшему символу.
  В случае бинарного алфавита данного множества дизъюнктов достаточно, чтобы упорядочить двух детей $d_{j}$ и $d_{j + 1}$ одного состояния $d_{i}$. 
  Дополнительно, для сокращения пространства поиска, можно добавить множество дизъюнктов $\left(p_{j,i} \wedge p_{j + 1, i} \rightarrow y_{i,l_{2},j + 1}\right)$ для $1 \leq i < j \leq M$. 
  Данные дизъюнкты задают порядок по уровню для детей одного родителя в случае бинарного алфавита.

  \item $\left(m_{i,l_{n},j} \leftrightarrow y_{i,l_{n},j} \wedge \neg y_{i,l_{n - 1}, j} \wedge \neg y_{i,l_{n - 2}, j} \wedge \ldots \wedge \neg y_{i,l_{1},j} \right)$ для $1 \leq i < j \leq M; 1 \leq n \leq L;l_{т} \in \Sigma$~{---} в автомате $\mathcal{D}$ символ $l_{n}$ является минимальным символом на переходах из состояния $d_{i}$ в состояние $d_{j}$ тогда и только тогда, когда в автомате существует переход из состояния $d_{i}$ в состояние $d_{j}$ по символу $l_{n}$, но не существует переходов по меньшим (относительно выбранного порядка) символам.
  Данное множество дизъюнктов используется в случае небинарного алфавита.

  \item $\left(p_{j,i} \wedge p_{j + 1, i} \wedge m_{i,l_{n}, j} -> \neg m_{i, l_{k}, j + 1}\right)$ для $1 \leq i < j \leq M; 1 \leq k < n \leq L;l_n,l_k \in \Sigma$~{---} если состояние $d_{i}$ является родителем в дереве BFS двух состояний $d_{j}$ и $d_{j + 1}$ и алфавит состоит из более чем двух символов, то из состояния $d_{i}$ переход в состояние $d_{j}$ должен быть по меньшему (относительно выбранного порядка) символу чем в состояние $d_{j + 1}$.
  Данные дизъюнкты задают порядок по уровню для детей одного родителя в случае небинарного алфавита.
\end{enumerate}

Все представленные выше наборы дизъюнктов могут быть объединены с помощью конкатенации в одну большую булеву формулу. Всего в такой формуле будет $\mathcal{O}(M^{3} + M^{2} \times L^{2})$ дизъюнктов и для их кодирования будет использовано $\mathcal{O}(M^2 \times L)$ переменных.

