%!TEX root = ../dissertation.tex

\chapter{Генерация всех детерминированных конечных автоматов по примерам поведения} 
\label{sec:findall}

В данной главе рассматривается задача генерации всех неизоморфных детерминированных конечных автоматов минимального размера, соответствующих заданным примерам поведения, которая ранее не имела эффективного решения.
Разрабатывается метод, основанный на подходе к решению задачи генерации одного ДКА с использованием программных средстве решения SAT, подробно описанный в разделе~\ref{sec:review:sat-dfa-inf}.
Рассматриваются два варианта использования программных средств решения SAT: перезапуск неинкрементального средства после нахождения каждого автомата и использование инкрементального средства~{---} если такое средство находит некоторое решение, то оно сохраняет свое текущее состояние и может принимать новые дизъюнкты.
Подробнее про инкрементальное решение SAT можно прочитать в%~\cite{Een-SAT03}.
Также в данной главе предлагается переборный метод, который служит базовым для сравнения с методом, основанным на сведении к задаче выполнимости.

%----------------------------------------------------------------------------------------

\section{Мотивация и формальная постановка задачи генерации всех неизоморных детерминированных конечных автоматов минимального размера по примерам поведения}
\label{sec:findall:problem}

\inote{расписать немного воды и мотивации}
\inote{ВАЖНО! не только найти все, но и доказать, что единственный!}
\inote{ФОРМАЛизовать и ФОРМАЛьно сФОРМУЛировать ЗАДАЧУ}

%----------------------------------------------------------------------------------------

\section{Метод, основанный на сведении к задаче выполнимости}
\label{sec:findall:SAT-based}

Как было описано в разделе~\ref{sec:review:sym-breaking:isomorphic-automata}, для каждого ДКА с $M$ состояниями существует $\mathcal{O}\left(M!\right)$ изоморфных ему автоматов.
Основной идеей предлагаемого метода по генерации всех ДКА является запрет (блокирование) найденных удовлетворяющих подстановок.
Очевидно, что без использования предикатов нарушения симметрии, придется блокировать $\mathcal{O}\left(M\right)$ изоморфных автоматов для каждого найденного уникального ДКА, что даже при $M = 10$ требует значительных вычислительных затрат.
Так как подход к нарушению симметрии с помощью большой клики, описанный в разделе~\ref{sec:review:sym-breaking:large-clique}, позволяет зафиксировать только нумерацию $k$ состояний, то метод, предложенный в~\cite{heule-icgi10} находит $\left(C - k\right)!$ изоморфных автоматов, что в общем случае все еще вычислительно сложно.

Предикаты нарушения симметрии на основе обхода в ширину, как было описано в разделе~\ref{sec:review:sym-breaking:bfs-based}, в свою очередь допускают единственного представителя каждого класса эквивалентности по изоморфизму.
Конкретно, BFS предикаты допускают BFS пронумерованный автомат.
Тогда, заблокировав единственный найденный автомат, автоматически блокируется весь класс эквивалентности, а значит далее программное средство может найти другой автомат только если он не является изоморфным ранее найденным.
Необходимо заметить, что несмотря на то, что идея блокировать найденные решения с целью найти остальные достаточно проста и известна, применять ее на практике невозможно без эффективных предикатов нарушения симметрии.
Так, ранее не было описано способов бороться с факториальным числом изоморфных автоматов, а значит и рассматриваемая задача не имела эффективного решения.
Использование BFS предикатов позволяет решить данную задачу путем добавления \emph{блокирующего} дизъюнкта в булеву формулу. 

Как было сказано в разделе~\ref{sec:review:dfa-inf:dfa-def}, детерминированным конечным автоматом называется пятерка $\mathcal{D} = \left(D,\Sigma,\delta,d_{1},D^{+}\right)$.
При построении автомата по найденной выполняющей подстановке множество состояний $D$ задано неявно через текущее число состояний автомата $M$, алфавит $\Sigma$~{---} через число $L$, стартовое состояние $d_{1}$ всегда имеет номер $1$, функция переходов $\delta$ определяется с помощью переменных переходов $y_{i,l,j}$, а множество допускающих состояний с помощью переменных допуска $z_{i}$.
Тогда достаточно из всей найденной выполняющей подстановки запретить только значения переменных переходов и значения переменных допуска.
Если с помощью $\varphi\left(q\right)$ обозначить значение переменной $q$ в найденной подстановке $\varphi$ и определить множество $\mathcal{Y} = \{y_{i,l,j} | i,j \in \left[M\right] \wedge l \in \Sigma \wedge \varphi\left(y_{i,l,j}\right) = 1\}$, то блокирующий дизъюнкт можно определить следующим образом:
\begin{equation*}
\bigwedge_{y \in \mathcal{Y}} \neg y \wedge \bigwedge_{i \in \left[M\right]}\neg \varphi\left(z_{i}\right).
\end{equation*}


Существует два различных способа использования программных средств для решения SAT.
Во-первых, можно перезапускать неинкрементальное средство с новой булевой формулой с добавленным блокирующим дизъюнктом после каждого нахождения выполняющей подстановки.
Недостатком данного подхода является то, что процесс поиска решения каждый раз начинается заново, и программное средство каждый раз проделывает полный объем работы по перебору пространства поиска.
Второй подход основан на использовании инкрементальных программных средств, которые после нахождения выполняющей подстановки сохраняют свое состояние и способны продолжить поиск решения после добавления некоторого уточнения, выраженного одним или несколькими дизъюнктами.

\inote{возможно, добавить схему всего этого.}

Необходимо заметить, что если найдено два автомата $\mathcal{D}_1 = \left(D,\Sigma,\delta,d_{1},D_{1}^{+}\right)$ и $\mathcal{D}_2 = \left(D,\Sigma,\delta,d_{1},D_{2}^{+}\right)$, которые различаются только множествами допускающих состояний, то можно сделать вывод, что в исходных примерах поведения нет строк, определяющих допуск одного или нескольких состояний автоматов $\mathcal{D}_{1}$ и $\mathcal{D}_{2}$.
Если использовать предложенный выше блокирующий дизъюнкт, то будут найдены все такие автоматы, отличающиеся лишь множествами допускающих состояний.
Таких автоматов будет $2^{k}$, если $k$~{---} это число состояний, для которых не хватает информации о допуске.
В общем случае, если в исходных данных не хватает информации, чтобы понять является ли состояние допускающим или нет, то не важно, будет ли данное состояние допускающим в найденном автомате.
Тогда блокирующий дизъюнкт можно сократить до следующего вида:
\begin{equation*}
\bigwedge_{y \in \mathcal{Y}} \neg y.
\end{equation*}


Также необходимо заметить, что так как всегда строится полный автомат, то бывают случаи, когда некоторые переходы найденного ДКА не покрываются переходами расширенного префиксного дерева.
Это значит, что существуют некоторые \emph{свободные} переходы, которые не используются при обработке любого из исходных примеров поведения.
Свободные переходы могут вести в любое состояние в найденном автомате, так как это не влияет на соответствие найденного ДКА примерам поведения.
Тогда существует $M^{k}$ автоматов, различающих только одним или несколькими из $k$ свободных переходов.
Как и в предыдущем случае, если в исходных данных не хватает информации, чтобы определить некоторый переход, то не важно, куда он будет вести.
Предлагается зафиксировать все свободные переходы в виде петель~{---} пусть все свободные переходы ведут в то же состояние откуда выходят.
Добиться этого можно с помощью дополнительных переменных использования (\textbf{u}sed) $\{u_{i,l}\}_{i \in \left[M\right],l \in \Sigma}$, которые истинны тогда и только тогда, когда существует переход из некоторой вершины префиксного дерева $\mathcal{T}$, соответствующей состоянию $d_{i}$ автомата $\mathcal{D}$, по символу $l$:
\begin{equation*}
\bigwedge_{1 \leq i \leq M} \bigwedge_{l \in \Sigma} u_{i,l} \leftrightarrow \bigvee_{v \in V_{l}}x_{v,i},
\end{equation*}

где $V_{l}$~{---} множество все состояний расширенного префиксного дерева, имеющих исходящее ребро по символу $l$, то есть $V_{l} = \{v | \exists w.\tau\left(v,l\right) = w\}$.

Тогда, зафиксировать свободные переходы в виде петель можно с помощью добавления следующего ограничения:
\begin{equation*}
\bigwedge_{1 \leq i \leq M} \bigwedge_{l \in \Sigma} \neg u_{i,l} \rightarrow y_{i,l,i}.
\end{equation*}

Данное ограничение выражается через $\mathcal{O}\left(M\times L\right)$ дизъюнктов.
\inote{рисунки}

\section{Алгоритм перебора с возвратами}
\label{sec:findall:backtracking}

\inote{не знаю, нужно ли? если заявляем, что раньше решения не было, то может и не нужен перебор? Он выглядит искусственно.}
Так как ранее не предлагалось методов для поиска всех возможных примеров поведения по заданным словарям, то был разработан переборный алгоритм с возвратами, не использующий никаких сторонних средств.
Псевдокод разработанного метода представлен на листинге~\ref{backtracking_algo}.


% \begin{algorithm}[ht]
%  \SetKwData{DFA}{DFA}\SetKwData{DFAPrime}{DFA$'$}\SetKwData{frontierPrime}{frontier$'$}\SetKwData{APTA}{APTA}\SetKwData{frontier}{frontier}\SetKwData{trans}{edge}
%  \SetKwData{source}{source}\SetKwData{dest}{destination}\SetKwData{DFAset}{DFAset}\SetKwData{lab}{label}
%  \SetKwFunction{MakeComplete}{MakeComplete}\SetKwFunction{FindNewFrontier}{FindNewFrontier}
%  \SetKwFunction{Backtracking}{Backtracking}\SetKwFunction{add}{add}
%  \KwData{augmented prefix tree acceptor \APTA, current \DFA (initially empty), \frontier (initially contains all APTA root outcoming edges)}
%  \DFAset $\leftarrow$ new Set$<$DFA$>$\\
%  \trans $\leftarrow$ any edge from \frontier\\
%  \ForEach{\dest $\in 1..|S|$}{
%   \source $\leftarrow$ the state of \DFA from which \trans should be added\\
%   \DFAPrime $\leftarrow$ \DFA $\cup$ transition(\source, \dest, \trans.\lab)\\
%   \frontierPrime $\leftarrow$ \FindNewFrontier{\APTA, \DFAPrime, \frontier}\\
%   \If{\upshape \frontierPrime $\ne null$}{
%    \uIf{\upshape \frontierPrime = $\varnothing$}{
%     \DFAset.\add{\MakeComplete{\DFAPrime}}\\
%    }\Else{
%     \DFAset.\add{\Backtracking{\APTA, \DFAPrime, \frontierPrime}}
%    }
%   }
%  }
%  \KwRet{\upshape \DFAset}
%  \caption{Переборный алгоритм с возвратами для генерации всех ДКА минимального размера}
% \label{backtracking_algo}
% \end{algorithm}


%----------------------------------------------------------------------------------------

\section{Реализация и экспериментальные исседования разработанных методов}
\label{sec:findall:results}

В настоящем разделе приводятся описание реализации разработанных методов и экспериментальные исследования, проведенные с ними.

%----------------------------------------------------------------------------------------

\subsection{Реализация разработанных методов генерации всех детерминированных конечных автоматов}
\label{sec:findall:results:impl}

Предложенный в предыдущем разделе метод генерации ДКА минимального размера на основе сведения к SAT и с использованием подхода уточнения абстракции по контрпримерам был реализован на языке \emph{python} как модуль программного комплекса \texttt{DFA-Inductor-py}.

%----------------------------------------------------------------------------------------

\subsection{Экспериментальные исследования разработанных методов генерации всех детерминированных конечных автоматов}
\label{sec:findall:results:dfs}

Результаты экспериментальных исследований представлены в таблице~\ref{tab:find-all}.
Эксперименты проводились для трех различных групп экземпляров задачи генерации ДКА по заданным примерам поведения.
В первой группе число примеров поведения относительно размера генерируемого автомата имело соотношение $S = 5 \times M$,
во второй~--- $S = 10 \times M$, в третьей $S = 25 \times M$.
Столбец $>$1 показывает процент экземпляров задачи, где существовало больше одного неизоморфного автомата.

\begin{table}[ht]
  \centering
  \caption{Медианное время нахождения всех различных ДКА с помощью метода на основе сведения к SAT с перезапуском программного средства (REST), метода на основе сведения к SAT с использованием инкрементального программного средства (INC) и переборного метода с возвратами (BTR)}
  \scalebox{0.65}{
    \begin{tabular}{ccccccccccccccc}
      \hline
      \multirow{2}{*}{$M$} & \multicolumn{4}{c}{$S = 5 \times M$}  & ~ & \multicolumn{4}{c}{$S = 10 \times M$} & ~ & \multicolumn{4}{c}{$S = 25 \times M$}\\\cline{2-5}\cline{7-10}\cline{12-15}
         & $>$1& REST   INC    & BTR            & & $>$1& REST  & INC  & BTR             & & $>$1& REST & INC  & BTR            \\\hline
      5  & 53  & 2.3   & 2.0   & 0.8            & & 40  & 3.6   & 3.3  & 1.3             & & 17  & 4.1  & 3.4  & 1.5           \\ 
      6  & 56  & 2.8   & 2.4   & 2.1            & & 31  & 4.7   & 3.9  & 1.7             & & 27  & 5.4  & 4.3  & 1.7           \\ 
      7  & 87  & 3.9   & 2.5   & 4.1            & & 27  & 3.7   & 3.0  & 3.1             & & 13  & 7.4  & 6.7  & 2.5          \\ 
      8  & 80  & 4.6   & 3.7   & 87.2           & & 34  & 7.0   & 6.5  & 41.7            & & 16  & 10.1  & 8.9 & 11.6 \\ 
      9  & 91  & 7.6   & 3.9   & 475.1          & & 50  & 7.7   & 6.4  & 121.6           & & 10  & 13.8 & 13.0 & 61.4 \\ 
      10 & 89  & 15.7  & 5.3   & 2756.2         & & 47  & 8.6   & 7.0  & 974.7           & & 11  & 18.8 & 16.1 & 276.8 \\
      11 & 94  & 19.9  & 7.3   & TL             & & 63  & 18.5  & 13.8 & 3108.0          & & 9   & 24.5 & 21.9 & 1158.4 \\
      12 & 90  & 28.0  & 9.9   & TL             & & 49  & 22.3  & 16.7 & TL              & & 8   & 33.5 & 27.2 & 3289.1 \\
      13 & 92  & 185.5 & 18.1  & TL             & & 57  & 36.9  & 22.6 & TL              & & 12  & 62.0 & 51.4 & TL \\
      14 & 87  & 408.5 & 49.0  & TL             & & 71  & 85.1  & 41.8 & TL              & & 4   & 67.0 & 56.2 & TL \\
      15 & 95  & 571.1 & 174.1 & TL             & & 69  & 193.3 & 95.7 & TL              & & 6   & 29.2 & 26.2 & TL \\
      \hline
    \end{tabular}
  }
  \label{tab:find-all}
\end{table}

Результаты экспериментов позволяют сделать несколько выводов.
Во-первых, впервые успешно решена задача генерации всех различных ДКА минимального размера по заданным примерам поведения.
Во-вторых, оба метода, использующие сведение к SAT, значительно превосходят по производительности переборный метод.
В-третьих, использование инкрементального программного средства, как и предполагалось, дает заметное преимущество относительно подхода с перезапуском программного средства, что объясняется сохранением промежуточного состояния инкрементальным программным средством после нахождения некоторого ДКА.
В-четвертых, чем больше примеров поведения дано для генерации ДКА, тем реже случается ситуация, когда существует несколько различных ДКА, соответствующих им.
Однако, надо заметить, что помимо количества примеров поведения, их качество не менее важно.


%----------------------------------------------------------------------------------------

\chresults{\ref{sec:findall}}
