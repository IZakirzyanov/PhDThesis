%!TEX root = ../dissertation.tex

\chapter{Генерация всех детерминированных конечных автоматов по примерам поведения} 
\label{sec:findall}

В данной главе рассматривается задача генерации всех неизоморфных детерминированных конечных автоматов минимального размера, соответствующих заданным примерам поведения, которая ранее не имела эффективного решения.
Разрабатывается метод, основанный на подходе к решению задачи генерации одного ДКА с использованием программных средстве решения SAT, подробно описанный в разделе~\ref{sec:review:sat-dfa-inf}.
Рассматриваются два варианта использования программных средств решения SAT: перезапуск неинкрементального средства после нахождения каждого автомата и использование инкрементального средства~{---} если такое средство находит некоторое решение, то оно сохраняет свое текущее состояние и может принимать новые дизъюнкты.
Подробнее про инкрементальное решение SAT можно прочитать в%~\cite{Een-SAT03}.
Также в данной главе предлагается переборный метод, который служит базовым для сравнения с методом, основанным на сведении к задаче выполнимости.

%----------------------------------------------------------------------------------------

\section{Мотивация и формальная постановка задачи генерации всех неизоморных детерминированных конечных автоматов минимального размера по примерам поведения}
\label{sec:findall:problem}

\inote{расписать немного воды и мотивации}
\inote{ВАЖНО! не только найти все, но и доказать, что единственный!}
\inote{ФОРМАЛизовать и ФОРМАЛьно сФОРМУЛировать ЗАДАЧУ}

%----------------------------------------------------------------------------------------

\section{Метод, основанный на сведении к задаче выполнимости}
\label{sec:findall:SAT-based}

Как было описано в разделе~\ref{sec:review:sym-breaking:isomorphic-automata}, для каждого ДКА с $M$ состояниями существует $\mathcal{O}\left(M!\right)$ изоморфных ему автоматов.
Основной идеей предлагаемого метода по генерации всех ДКА является запрет (блокирование) найденных удовлетворяющих подстановок.
Очевидно, что без использования предикатов нарушения симметрии, придется блокировать $\mathcal{O}\left(M\right)$ изоморфных автоматов для каждого найденного уникального ДКА, что даже при $M = 10$ требует значительных вычислительных затрат.
Так как подход к нарушению симметрии с помощью большой клики, описанный в разделе~\ref{sec:review:sym-breaking:large-clique}, позволяет зафиксировать только нумерацию $k$ состояний, то метод, предложенный в~\cite{heule-icgi10} находит $\left(C - k\right)!$ изоморфных автоматов, что в общем случае все еще вычислительно сложно.

Предикаты нарушения симметрии на основе обхода в ширину, как было описано в разделе~\ref{sec:review:sym-breaking:bfs-based}, в свою очередь допускают единственного представителя каждого класса эквивалентности по изоморфизму.
Конкретно, BFS предикаты допускают BFS пронумерованный автомат.
Тогда, заблокировав единственный найденный автомат, автоматически блокируется весь класс эквивалентности, а значит далее программное средство может найти другой автомат только если он не является изоморфным ранее найденным.
Необходимо заметить, что несмотря на то, что идея блокировать найденные решения с целью найти остальные достаточно проста и известна, применять ее на практике невозможно без эффективных предикатов нарушения симметрии.
Так, ранее не было описано способов бороться с факториальным числом изоморфных автоматов, а значит и рассматриваемая задача не имела эффективного решения.
Использование BFS предикатов позволяет решить данную задачу путем добавления \emph{блокирующего} дизъюнкта в булеву формулу. 

Как было сказано в разделе~\ref{sec:review:dfa-inf:dfa-def}, детерминированным конечным автоматом называется пятерка $\mathcal{D} = \left(D,\Sigma,\delta,d_{1},D^{+}\right)$.
При построении автомата по найденной выполняющей подстановке множество состояний $D$ задано неявно через текущее число состояний автомата $M$, алфавит $\Sigma$~{---} через число $L$, стартовое состояние $d_{1}$ всегда имеет номер $1$, функция переходов $\delta$ определяется с помощью переменных переходов $y_{i,l,j}$, а множество допускающих состояний с помощью переменных допуска $z_{i}$.
Тогда достаточно из всей найденной выполняющей подстановки запретить только значения переменных переходов и значения переменных допуска.
Если с помощью $\varphi\left(q\right)$ обозначить значение переменной $q$ в найденной подстановке $\varphi$ и определить множество $\mathcal{Y} = \{y_{i,l,j} | i,j \in \left[M\right] \wedge l \in \Sigma \wedge \varphi\left(y_{i,l,j}\right) = 1\}$, то блокирующий дизъюнкт можно определить следующим образом: $$\bigwedge_{y \in \mathcal{Y}} \neg y \wedge \bigwedge_{i \in \left[M\right]}\neg \varphi\left(z_{i}\right).$$

Существует два различных способа использования программных средств для решения SAT.
Во-первых, можно перезапускать неинкрементальное средство с новой булевой формулой с добавленным блокирующим дизъюнктом после каждого нахождения выполняющей подстановки.
Недостатком данного подхода является то, что процесс поиска решения каждый раз начинается заново, и программное средство каждый раз проделывает полный объем работы по перебору пространства поиска.
Второй подход основан на использовании инкрементальных программных средств, которые после нахождения выполняющей подстановки сохраняют свое состояние и способны продолжить поиск решения после добавления некоторого уточнения, выраженного одним или несколькими дизъюнктами.

\inote{возможно, добавить схему всего этого.}

Необходимо заметить, что если найдено два автомата $\mathcal{D}_1 = \left(D,\Sigma,\delta,d_{1},D_{1}^{+}\right)$ и $\mathcal{D}_2 = \left(D,\Sigma,\delta,d_{1},D_{2}^{+}\right)$, которые различаются только множествами допускающих состояний, то можно сделать вывод, что в исходных примерах поведения нет строк, определяющих допуск одного или нескольких состояний автоматов $\mathcal{D}_{1}$ и $\mathcal{D}_{2}$.
Если использовать предложенный выше блокирующий дизъюнкт, то будут найдены все такие автоматы, отличающиеся лишь множествами допускающих состояний.
Таких автоматов будет $2^{k}$, если $k$~{---} это число состояний, для которых не хватает информации о допуске.
В общем случае, если в исходных данных не хватает информации, чтобы понять является ли состояние допускающим или нет, то не важно, будет ли данное состояние допускающим в найденном автомате.
Тогда блокирующий дизъюнкт можно сократить до следующего вида: $$\bigwedge_{y \in \mathcal{Y}} \neg y.$$

Также необходимо заметить, что так как всегда строится полный автомат, то бывают случаи, когда некоторые переходы найденного ДКА не покрываются переходами расширенного префиксного дерева.
Это значит, что существуют некоторые \emph{свободные} переходы, которые не используются при обработке любого из исходных примеров поведения.
Свободные переходы могут вести в любое состояние в найденном автомате, так как это не влияет на соответствие найденного ДКА примерам поведения.
Тогда существует $M^{k}$ автоматов, различающих только одним или несколькими из $k$ свободных переходов.
Как и в предыдущем случае, если в исходных данных не хватает информации, чтобы определить некоторый переход, то не важно, куда он будет вести.
Предлагается зафиксировать все свободные переходы в виде петель~{---} пусть все свободные переходы ведут в то же состояние откуда выходят.
Добиться этого можно с помощью дополнительных переменных использования (\textbf{u}sed) $\{u_{i,l}\}_{i \in \left[M\right],l \in \Sigma}$, которые истинны тогда и только тогда, когда существует переход из некоторой вершины префиксного дерева $\mathcal{T}$, соответствующей состоянию $d_{i}$ автомата $\mathcal{D}$, по символу $l$: $$\bigwedge_{1 \leq i \leq M} \bigwedge_{l \in \Sigma} u_{i,l} \leftrightarrow \bigvee_{v \in V_{l}}x_{v,i},$$
где $V_{l}$~{---} множество все состояний расширенного префиксного дерева, имеющих исходящее ребро по символу $l$, то есть $V_{l} = \{v | \exists w.\tau\left(v,l\right) = w\}$.

Тогда, зафиксировать свободные переходы в виде петель можно с помощью добавления следующего ограничения: $$\bigwedge_{1 \leq i \leq M} \bigwedge_{l \in \Sigma} \neg u_{i,l} \rightarrow y_{i,l,i}.$$
Данное ограничение выражается через $\mathcal{O}\left(M\times L\right)$ дизъюнктов.
\inote{рисунки}

\section{Алгоритм перебора с возвратами}
\label{sec:findall:backtracking}

\inote{не знаю, нужно ли? если заявляем, что раньше решения не было, то может и не нужен перебор? Он выглядит искусственно.}

%----------------------------------------------------------------------------------------

\section{Реализация и экспериментальные исседования разработанных методов}
\label{sec:findall:results}

%----------------------------------------------------------------------------------------

\subsection{Реализация разработанных методов генерации всех детерминированных конечных автоматов}
\label{sec:findall:results:impl}

%----------------------------------------------------------------------------------------

\subsection{Экспериментальные исследования разработанных методов генерации всех детерминированных конечных автоматов}
\label{sec:findall:results:dfs}

%----------------------------------------------------------------------------------------

\chresults{\ref{sec:findall}}
