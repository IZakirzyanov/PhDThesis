%!TEX root = ../dissertation.tex

\chapter{Генерация всех детерминированных конечных автоматов по примерам поведения} 
\label{sec:findall}

В данной главе рассматривается задача генерации всех неизоморфных детерминированных конечных автоматов минимального размера, соответствующих заданным примерам поведения, которая ранее не имела эффективного решения.
Разрабатывается метод, основанный на подходе к решению задачи генерации одного ДКА с использованием программных средстве решения SAT, подробно описанный в разделе~\ref{sec:review:sat-dfa-inf}.
Рассматриваются два варианта использования программных средств решения SAT: перезапуск неинкрементального средства после нахождения каждого автомата и использование инкрементального средства~{---} если такое средство находит некоторое решение, то оно сохраняет свое текущее состояние и может принимать новые дизъюнкты.
Подробнее про инкрементальное решение SAT можно прочитать в%~\cite{Een-SAT03}.
Также в данной главе предлагается переборный метод, который служит базовым для сравнения с методом, основанным на сведении к задаче выполнимости.

%----------------------------------------------------------------------------------------

\section{Метод, основанный на сведении к задаче выполнимости}
\label{sec:findall:SAT-based}

Как было описано в разделе~\ref{sec:review:sym-breaking:isomorphic-automata}, для каждого ДКА с $M$ состояниями существует $\mathcal{O}\left(M!\right)$ изоморфных ему автоматов.
Основной идеей предлагаемого метода по генерации всех ДКА является запрет (блокирование) найденных удовлетворяющих подстановок.
Очевидно, что без использования предикатов нарушения симметрии, придется блокировать $\mathcal{O}\left(M\right)$ изоморфных автоматов для каждого найденного уникального ДКА, что даже при $M = 10$ требует значительных вычислительных затрат.
Так как подход к нарушению симметрии с помощью большой клики, описанный в разделе~\ref{sec:review:sym-breaking:large-clique}, позволяет зафиксировать только нумерацию $k$ состояний, то метод, предложенный в~\cite{heule-icgi10} находит $\left(C - k\right)!$ изоморфных автоматов, что в общем случае все еще вычислительно сложно.

Предикаты же нарушения симметрии на основе обхода в ширину, как было описано в разделе~\ref{sec:review:sym-breaking:bfs-based}, допускают единственного представителя каждого класса эквивалентности по изоморфизму.
Конкретно, BFS предикаты допускают BFS пронумерованный автомат.
Тогда, заблокировав некоторый найденный автомат, автоматически блокируется весь класс эквивалентности, а значит программное средство может найти другой автомат неизоморфный ранее найденным.
Необходимо заметить, что несмотря на то, что идея блокировать найденные решения с целью найти остальные достаточно проста и известна, применять ее на практике невозможно без эффективных предикатов нарушения симметрии.
Так, ранее не было описано способов бороться с факториальным числом изоморфных автоматов, а значит и рассматриваемая задача не имела эффективного решения.
