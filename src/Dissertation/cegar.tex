%!TEX root = ../dissertation.tex

\chapter{Генерация детерминированных конечных автоматов по избыточным примерам поведения} 
\label{sec:cegar}

В настоящей главе описывается разработка, реализация и экспериментальные исследования комбинированного метода генерации детерминированных конечных автоматов, на основе сведения к задаче выполнимости булевых формул и с использованием подхода уточнения абстракции по контрпримерам.

\section{Границы применимости (масштабируемость) предложенных методов в зависимости от размера расширенного префиксного дерева} 
\label{sec:cegar:motivation}

Как было показано в разделе~\ref{sec:space:results:bfs}, предложенный метод генерации детерминированных конечных автоматов с минимальным числом состояний по заданным примерам поведения с использованием предикатов нарушения симметрии на основе кодирования алгоритма обхода графа в ширину является самым эффективным из известных точных методов.
% Можно заметить, что число ДКА с $M$ состояниями и мощностью алфавита $\abs{\Sigma}=L$ равняется $M \times M^{M \times L} \times 2^{M}$.
% Действительно, существуют $M$ различных способов выбрать стартовое состояние, $M^{M \times L}$ различных функций перехода (ее можно представить в виде таблицы размера $M \times L$, где в каждой ячейке находится одно из $M$ состояний) и $2^{M}$ различных способа выбрать принимающие состояния.
% Как виднПри увеличении размера искомого автомата, размера пространства поиска растет очень быстро
При увеличении размера искомого автомата, увеличивается и пространство поиска.
Глава~\ref{sec:space} настоящей диссертации посвящена разработке различных предикатов нарушения симметрии, позволяющих быстрее отсекать различные области пространства поиска.
Большая часть из предложенных предикатов нарушения симметрии определяют нумерацию искомого автомата и позволяют отсекать большое число решений вне зависимости от имеющихся примеров поведения.
Однако, исходное сведение, описанное в разделе~\ref{sec:review:sat-dfa-inf:dfasat}, сильно зависит от числа имеющихся примеров поведения~--- чем больше примеров поведения имеется, тем проще и быстрее будут отыскиваться конфликты при попытках построить различные ДКА.

С другой стороны, булева формула, кодирующая задачу генерации ДКА по примерам поведения на языке SAT, состоит из $\mathcal{O}\left(N \times M^2\right)$ дизъюнктов ($N$~--- размер расширенного префиксного дерева, $M$~--- размер искомого автомата), а значит ее размер линейно зависит от числа состояний в расширенном префиксном дереве.
Число используемых переменных также линейно зависит от размера префиксного дерева~--- $\mathcal{O}(M^2 + N \times M)$.
Несмотря на то, что современные программные средства для решения SAT могут решать задачи с большим числом переменных и большим числом дизъюнктов, работа со слишком большой формулой требует больших временных затрат на работу с ней и больших затрат памяти для хранения всех дизъюнктов.
Таким образом, получается, что для программного средства плохо, когда примеров поведения слишком мало, и также плохо, когда примеров поведения слишком много.
Ситуацию с недостаточным числом примеров поведения нельзя решить без получения новых примеров поведения, что выбивается за рамки решаемой задачи.
В случае же \emph{избыточных данных} логичным решением является попытаться построить автомат по части примеров поведения, однако вопрос выбора этой части не является тривиальным.
Среди тысяч или десятков тысяч примеров поведения, может быть единственный пример поведения, описывающий некоторую часть автомата, которую не описывают другие примеры поведения.
В следующем разделе приводится описание разработанного метода генерации ДКА по избыточному числу примеров поведения, позволяющего итеративно выбирать ``нужные'' примеры поведения, отсекая лишние.

\section{Метод генерации детерминированных конечных автоматов на основе сведения к задаче выполнимости и с использованием подхода уточнения абстракции по контрпримерам}
\label{sec:cegar:cegar-algo}

%далее копипаста
Суть данного метода можно описать следующим образом.
На начальном шаге генерируется некоторая, возможно случайная модель.
Затем на каждом следующем шаге данная модель проходит проверку некоторой проверяющей системы. Если проверка проходит успешно, то искомая модель найдена.
Иначе система возвращает один или несколько контрпримеров, которые затем используются для улучшения модели.
Процесс повторяется, пока не будет найдена модель, проходящая проверку системы.
Данный подход больше похож на метод активного построения модели, в то время как в данной работе рассматривается задача пассивного построения~--- все примеры поведения известны заранее и никакой дополнительной информации в ходе построения автомата быть получено не может.
Однако далее приводится описание того, как метод уточнения абстракции можно применить для построения ДКА.
%---------------

Как и классический алгоритм CEGAR, предлагаемый метод итеративно уточняет модель, которая в настоящей диссертации является детерминированным конечным автоматом.
Изначально расширенное префиксное дерево не содержит вершин, но будет достраиваться на каждом шаге.
На каждом шаге работы алгоритма предлагается с помощью сведения к SAT пытаться строить ДКА текущего размера по текущему префиксному дереву.
Если такой ДКА не существует, то как и раньше размер искомого автомата увеличивается на единицу и процесс поиска повторяется.
Если же такой автомат найден, он проверяется на соответствие всему множеству примеров поведения.
Если ДКА соответствует всем примерам поведения, то задача решена.
Иначе, среди тех примеров поведения, которым построенный автомат не соответствует, выбирается один или несколько контрпримеров, по которым достраивается префиксное дерево, строится новая булева формула и поиск продолжается.
Схема предложенного метода представлена на рисунке~\ref{img:cegar-algo}.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.5]{img/ntv/cegar.jpg}
  \caption{Схема точного метода генерации ДКА по избыточному набору примеров поведения на основе сведения к SAT и с использованием подхода CEGAR}
  \label{img:cegar-algo}
\end{figure}

Необходимо заметить, что перезапускать программное средство для решения SAT при каждом достраивании префиксного дерева крайне неэффективно, так как при добавлении новых дизъюнктов в формулу, пространство поиска решения SAT только сужается, а значит нет необходимости начинать поиск выполняющей подстановки заново.
Можно использовать инкрементальные программные средства, которые после нахождения некоторой выполняющей подстановки переходят в режим ожидания новых дизъюнктов и затем продолжают поиск решения уже для новой уточненной формулы с того места, где остановились в прошлый раз.


%----------------------------------------------------------------------------------------

\section{Реализация и экспериментальные исследования разработанного метода}
\label{sec:cegar:results}

В настоящем разделе приводятся описание реализации разработанных методов и экспериментальные исследования, проведенные с ними.

%----------------------------------------------------------------------------------------

\subsection{Реализация разработанного комбинированного метода генерации детерминированных конечных автоматов}
\label{sec:cegar:results:impl}

Предложенный в предыдущем разделе комбинированный метод построения ДКА минимального размера на основе сведения к SAT и с использованием подхода уточнения абстракции по контрпримерам был реализован на языке \emph{python} как модуль программного комплекса \texttt{DFA-Inductor-py}.

%----------------------------------------------------------------------------------------

\subsection{Экспериментальные исследования разработанного метода комбинированного метода генерации детерминированных конечных автоматов}
\label{sec:cegar:results:cegar}

%далее копипаста
Эксперименты проводились на персональном компьютере с процессором \emph{QuadCore Intel Core i7-8550U} @ 4 ГГц, 16 ГБ оперативной памяти и операционной системой \emph{ArchLinux 5.5.6}. Для проведения экспериментов было сгенерировано 100 тестовых экземпляров с помощью алгоритма, разработанного автором ранее и описанного в~\cite{zakirzyanov2017DataMode}.
Параметры для генерации автоматов были выбраны следующим образом:
\begin{itemize}
  \item размеры автоматов, которые нужно построить,~--- $M \in \left[15; 25\right]$;
  \item число примеров поведения $S = S_{+} \cup S_{-} \in \{50 \times N; 100 \times N; 200 \times N; 500 \times N\}$.
\end{itemize}
В экспериментах проводилось сравнение разработанного комбинированного метода с предложенным в~\cite{zakirzyanov2019LATA} методом, основанным только на сведении к SAT.
Результаты показали, что при относительно небольшом количестве примеров поведения ($S \in \{50 \times N; 100 \times N\}$) использование комбинированного подхода сокращает время построения вспомогательных структур данных (таких как граф совместимости) и время построения булевой формулы, но увеличивает время работы программного средства для решения SAT и, как следствие, суммарное время решения задачи.
Однако в случае, когда количество примеров поведения достаточно велико ($S \in \{200 \times N; 500 \times N\}$), использование предложенного подхода позволяет использовать меньше половины примеров поведения вместо всех, что сокращает как время построения структур данных и булевой формулы, так и время работы программного средства для решения SAT.
Выигрыш достигает $30 \%$ на экземплярах, которые оба метода смогли решить за 12 часов.
Значительная часть таких экземпляров не были в принципе решены методом, основанным только на сведении к SAT.
Таким образом, можно сделать вывод, что использование разработанного метода целесообразно, когда количество примеров поведения велико, и метод, основанный только на сведении к SAT, не применим ввиду слишком большой формулы.
%---------------

%----------------------------------------------------------------------------------------

\chresults{\ref{sec:cegar}}
