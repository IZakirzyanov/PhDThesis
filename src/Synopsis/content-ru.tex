%!TEX root = ../dissertation.tex

\section*{Общая характеристика работы} %\addcontentsline{toc}{section}{Общая характеристика работы}

\input{common/characteristic-ru}

\newpage

\section*{Содержание работы}

Во \textbf{введении} диссертационной работы обоснована актуальность проводимых исследований. Сформулированы цель, задачи и положения, выносимые на защиту. Изложена научная новизна, теоретическая и практическая значимость результатов, полученных в диссертационной работе.

\textbf{\underline{Первая глава}} диссертации посвящена обзору предметной области и результатов существующих исследований, посвященных генерации детерминированных конечных автоматов.
Кроме того, в первой главе приведены терминология, основные определения и известные результаты ряда разделов информатики, необходимых для описания предлагаемых в диссертации методов и алгоритмов.

\insection{\ref{sec:review:sat}} приведена формальная постановка задачи выполнимости булевой формулы, даны необходимые определения, и представлено краткое описание основных подходов к ее решению.
Также в данном разделе описан подход к решению NP-трудных задач с помощью полиномиального сведения таких задач к задаче выполнимости.
Помимо этого, приводится краткий обзор существующих программных средств решения SAT.

Булева формула задана в \emph{конъюнктивно-нормальной форме} (КНФ), если является конъюнкцией дизъюнктов~--- множества литералов, связанных дизъюнкцией.
\emph{Задача выполнимости булевой формулы} (\emph{задача выполнимости}, \emph{boolean satisfiability problem}~{---} SAT) заключается в определении, существует ли для некоторой булевой формулы, заданной в КНФ, выполняющая подстановка~--- набор значений переменных, при подстановке которых формула принимает истинное значение.
Задача выполнимости является исторически первой, для которой была доказана NP-трудность~--- любую задачу из класса NP можно за полиномиальное время свести к SAT.
Данный факт объясняет актуальность разработки все более эффективных программных средств для решения задачи выполнимости.
Ежегодно в научном сообществе проходят соревнования по выявлению лучшего программного средства для решения SAT, что также способствует постоянному развитию данной области.
В основе современных программных средств решения SAT лежит стратегия \emph{управляемого конфликтами обучения дизъюнктов} (\emph{conflict-driven clause learning}, CDCL).

Подход к решению задачи из класса NP, когда разрабатывается сведение к SAT и затем используется современное программное средство для поиска выполняющей подстановки, зачастую оказывается заметно эффективнее и проще, чем разработка применимого на практике метода, непосредственно решающего исходную задачу.
Еще одним немаловажным достоинством такого подхода является тот факт, что достаточно единожды написать сведение к SAT, а затем без прикладывания каких-либо усилий пользоваться развитием программных средств, выбирая самое эффективное из них.

\insection{\ref{sec:review:dfa-inf}} приведены базовые понятия о детерминированных конечных автоматах и постановка задачи генерации детерминированных конечных автоматов по примерам поведения. 
Примерами поведения некоторого ДКА $\mathcal{D}$ называются два множества слов, состоящих из символов алфавита автомата, $S_{+}$ и $S_{-}$ таких, что все слова из $S_{+}$ принадлежат языку $\mathcal{L}\left(\mathcal{D}\right)$~--- должны им приниматься, а все слова из $S_{-}$ не принадлежат языку $\mathcal{L}\left(\mathcal{D}\right)$~--- должны им отвергаться.
Задача генерации ДКА по примерам поведения заключается в поиске автомата минимального размера (с минимальным числом состояний), соответствующего имеющимся примерам поведения.
Ранее было доказано, что настоящая задача является NP-полной, ровно как и задача генерации ДКА любого фиксированного размера, соответствующего имеющимся примерам поведения.
Пример детерминированного конечного автомата, соответствующего наборам примеров поведения $S_{+} = \{aba, bb, bba\}$ и $S_{-} = \{b, ba\}$, представлен на рисунке~\ref{syn:img:dfa-ex}.
Можно заметить, что автомата размера два, соответствующего множествам $S_{+}$ и $S_{-}$, не существует.

\begin{figure}[ht]
  \centering
  \ifafour
    \input{img/FIG1-a4}
    % \includegraphics[scale=0.16]{img/datamod/FIG1.eps}
  \else
    \input{img/FIG1-a5}
  \fi
  \caption{Пример ДКА минимального размера, соответствующего наборам примеров поведения $S_{+} = \{aba, bb, bba\}$ и $S_{-} = \{b, ba\}$}
  \label{syn:img:dfa-ex}
\end{figure}


\insection{\ref{sec:review:heuristic-dfa-inf}} приведен обзор существующих эвристических и метаэвристических методов генерации детерминированных конечных автоматов по примерам поведения. 

Среди эвристических алгоритмов можно выделить алгоритм \emph{объединения состояний на основе свидетельств} (\emph{evidence-driven state merging}~--- EDSM).
Метаэвристические методы основаны на эволюционных стратегиях, генетических и муравьиных алгоритмах.

Следует отметить, что данные походы являются неточными~--- ими не гарантируется, что найденный автомат содержит минимальное возможное число состояний, а иногда вообще не гарантируется, что удовлетворяющий автомат будет найден.

\insection{\ref{sec:review:sat-dfa-inf}} приведен обзор существующих методов генерации детерминированных конечных автоматов по примерам поведения, основанных на сведении к SAT. В отличие от эвристических и метаэвристических подходов, данные методы являются точными~--- гарантируется, что автомат, соответствующий примерам поведения, будет построен за конечное время и будет содержать минимальное возможное число состояний.

Первым шагом рассматриваемых методов является построение расширенного префиксного дерева (augmented prefix tree acceptor~--- APTA)~--- древовидной структуры данных, основанной на обычном префиксном дереве, в которой каждая вершина либо не помечена, либо помечена как допускающая или отвергающая. 
Пример расширенного префиксного дерева представлен на рисунке~\ref{syn:img:apta-ex}.

\begin{figure}[ht]
  \centering
  \ifafour
    \input{img/FIG2a-a4}
    %\includegraphics[scale=0.14]{img/datamod/FIG2a.eps}
  \else
    \input{img/FIG2a-a5}
  \fi
  \caption{Пример расширенного префиксного дерева, построенного по наборам примеров поведения $S_{+} = \{aba, bb, bba\}$ и $S_{-} = \{b, ba\}$}
  \label{syn:img:apta-ex}
\end{figure}

Далее, начиная с некоторой нижней оценки на размер~--- в простейшем случае с единицы~--- происходит поиск автомата текущего размера, соответствующего построенному расширенному префиксному дереву. 
Данный процесс продолжается до тех пор, пока не будет найден ДКА, удовлетворяющий заданным требованием.
Итеративный перебор размера от меньшего к большему гарантирует, что найденный автомат имеет минимальный размер.
Как уже было сказано, задача поиска ДКА конкретного размера по заданным примерам поведения принадлежит классу NP, а значит, может быть решена путем сведения к некоторой NP-трудной задаче.
Самым производительным точным методом до недавнего времени являлся \texttt{DFASAT}~\cite{heule-icgi10}, в котором авторы предложили сначала свести задачу генерации ДКА к задаче раскраски графа~--- необходимо раскрасить расширенное префиксное дерево в минимальное число цветов так, чтобы все вершины одного цвета объединялись в одно состояние,~--- которую затем свести к задаче выполнимости.
Схема метода \texttt{DFASAT} представлена на рисунке~\ref{syn:img:dfasat-algo}.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.9]{img/ntv/basic.pdf}
  \caption{Схема точного метода генерации ДКА по заданным примерам поведения на основе сведения к SAT~--- \texttt{DFASAT}}
  \label{syn:img:dfasat-algo}
\end{figure}

Авторы \texttt{DFASAT} используют несколько различных подходов к сокращению пространства поиска:
\begin{enumerate}
  \item добавление нескольких видов дополнительных дизъюнктов в булеву формулу, которые не влияют на решение, но добавляют дополнительные ограничения на возможные значения переменных;
  \item построение графа совместимости, позволяющего заранее найти некоторые пары вершин префиксного дерева, которые не могут быть объединены в одно состояние автомата;
  \item нахождение некоторой большой клики в графе совместимости и фиксирование нумерации вершин данной клики.
\end{enumerate}

Использование вышеперечисленных подходов позволяет значительно увеличить производительность оригинального метода, однако они не решают фундаментальной проблемы наличия изоморфных автоматов.
Два автомата называются изоморфными, если они различаются только нумерацией состояний.
Таким образом, если ДКА содержит $N$ состояний, то существует $\mathcal{O}\left(N!\right)$ изоморфных ему автоматов.
Несмотря на то, что изоморфные автоматы не отличаются с практической точки зрения, с точки зрения программного средства для решения SAT они различны.

Решением данной проблемы стала разработка предикатов нарушения симметрии на основе \emph{обхода графа в ширину} (\emph{breadth-first search}~--- BFS)~\cite{zakirzyanov2015LATA}.
Добавление таких предикатов в булеву формулу фиксирует нумерацию рассматриваемых автоматов в порядке BFS, что для каждого класса эквивалентности по изоморфизму позволяет оставить для рассмотрения единственного представителя.
Для записи предикатов в виде булевой формулы требуется $\mathcal{O}\left(M^{3} + M^{2} \times L^{2}\right)$ дизъюнктов, где $N$~--- размер префиксного дерева, $M$~--- размер искомого ДКА.
Был разработан метод генерации ДКА при помощи сведения к SAT, использующий предложенные предикаты нарушения симметрии, который был реализован в виде программного средства \texttt{DFA-Inductor}~\cite{dfa-inductor}. 
Метод генерации ДКА при помощи сведения к SAT с использованием BFS-предикатов нарушения симметрии является наиболее производительным точным методом, который лежит в основе всех методов, разрабатываемых в данной диссертации.
Пример BFS-пронумерованного ДКА представлен на рисунке~\ref{syn:img:bfs:bfs-ex}, а на рисунке~\ref{syn:img:bfs:bfs-tree} представлено его дерево обхода.

\begin{figure}[ht]
  \centering
  \subfloat[Пример BFS-пронумерованного автомата\label{syn:img:bfs:bfs-ex}]{
    \ifafour
      \input{img/BFS-example-a4}
      % \includegraphics[scale=0.15]{img/datamod/BFS-example.eps}
    \else
      \input{img/BFS-example-a5}
    \fi
  }
  \hfill
  \subfloat[Дерево BFS для автомата, представленного на рисунке~\ref{syn:img:bfs:bfs-ex}\label{syn:img:bfs:bfs-tree}]{
    \ifafour
      \input{img/BFS-tree-a4}
    % \includegraphics[scale=0.15]{img/datamod/BFS-tree.eps}
    \else
      \input{img/BFS-tree-a5}
    \fi
  }
  \caption{Пример BFS-пронумерованного автомата и соответствующего BFS-дерева}
  \label{syn:img:bfs}
\end{figure}

\insection{\ref{sec:review:cegar}} приведено описание алгоритма уточнения абстракции по контрпримерам (counterexample guided abstraction refinement~{---} CEGAR). 
Методы, использующие данный алгоритм, применимы в ситуации, когда необходимо построить модель, соответствующую заданным требованиям, имея при этом доступ к некоторой проверяющей системе~--- оракулу. 
На начальном шаге строится некоторая, возможно, случайная модель.
Затем начинается итеративный процесс уточнения имеющейся модели~--- на каждом шаге текущая модель проверяется оракулом на соответствие заданным требованиям. 
Если проверка проходит успешно, то модель найдена.
Иначе, оракул сообщает один или несколько контрпримеров, которые затем используются для уточнения модели.

%------

Во \textbf{\underline{второй главе}} настоящей диссертации описываются разработка, реализация и экспериментальные исследования методов генерации детерминированных конечных автоматов с использованием различных подходов к сокращению пространства поиска при решении задачи выполнимости.

\insection{\ref{sec:space:dfs}} приведено описание разработанных предикатов нарушения симметрии на основе кодирования алгоритма обхода графа в глубину (\emph{depth-first search}~--- DFS). 
Использование предикатов нарушения симметрии, задающих BFS нумерацию автомата, ранее позволило значительно улучшить производительность метода \texttt{DFASAT}.
Логично в качестве следующей задачи научного исследования было разработать предикаты нарушения симметрии на основе алгоритма DFS и метод, использующий их.
Пример DFS-пронумерованного ДКА представлен на рисунке~\ref{syn:img:dfs:dfs-ex}, а на рисунке~\ref{syn:img:dfs:dfs-tree} представлено его дерево обхода.

\begin{figure}[ht]
  \centering
  \subfloat[Пример DFS-пронумерованного автомата\label{syn:img:dfs:dfs-ex}]{
    \ifafour
      % \includegraphics[scale=0.15]{img/datamod/DFS-example.eps}
      \input{img/DFS-example-a4}
    \else
      \input{img/DFS-example-a5}
    \fi
  }
  \hfill
  \subfloat[Дерево DFS для автомата, представленного на рисунке~\ref{syn:img:dfs:dfs-ex}\label{syn:img:dfs:dfs-tree}]{
    \ifafour
      % \includegraphics[scale=0.15]{img/datamod/DFS-tree.eps}
      \input{img/DFS-tree-a4}
    \else
      \input{img/DFS-tree-a5}
    \fi
  }
  \caption{Пример DFS-пронумерованного автомата и соответствующего DFS-дерева}
  \label{syn:img:dfs}
\end{figure}

Разработанные предикаты выражаются КНФ-формулой, содержащей $\mathcal{O}\left(M^{4} + M^{3} \times L^{2}\right)$ дизъюнктов, что в $M$ раз больше чем предикаты, задающие BFS нумерацию ДКА.

\insection{\ref{sec:space:tight}} приведено описание разработанных компактных предикатов нарушения симметрии на основе кодирования алгоритма BFS.

Компактность разработанных предикатов заключается в том, что удалось сократить размер формулы, выражающей предикаты нарушения симметрии, задающие BFS нумерацию автомата, с $\mathcal{O}\left(M^{3} + M^{2} \times L^{2}\right)$ дизъюнктов до $\mathcal{O}\left(M^{2} \times L\right)$ дизъюнктов.
Анализ ограничений исходного сведения, которые выражались через $\mathcal{O}\left(M^{3}\right)$ и $\mathcal{O}\left(M^{2} \times L^{2}\right)$ дизъюнктов, показал, что часть параметров, задающих размер формулы, являются независимыми, в то время как другие параметры могут быть исключены с помощью добавления новых переменных. 
Для каждого такого ограничения был разработан способ сделать его более компактным, что и позволило сократить общий размер формулы.
Помимо этого, б\emph{о}льшая часть дизъюнктов из оригинального сведения, которые состояли из $\mathcal{O}\left(M\right)$ литералов,
были заменены на дизъюнкты, состоящие из двух или трех литералов, что заметно влияет на производительность программного средства для решения SAT, так как такие дизъюнкты обрабатываются за константное время и не хранятся в памяти~\cite{MSilva-SATbook09}.

\insection{\ref{sec:space:pruning}} приведено описание разработанных подходов к сокращению пространства поиска при генерации детерминированных конечных автоматов, основанных на особенностях структуры BFS-дерева, а также на связях между расширенным префиксным деревом и искомым ДКА.
На рисунке~\ref{syn:img:full-bfs} представлено полное BFS-дерево произвольного размера над произвольным алфавитом размера $L$.
Дерево названо полным, так как каждая вершина имеет ровно $L$ детей.

\begin{figure}[ht]
  \centering
  \scalebox{0.625}{\input{img/lata19/texfigs/worst-case-bfs-tree}}
  \caption{Полное BFS-дерево, где $\abs{\Sigma}=L$}
  \label{syn:img:full-bfs}
\end{figure}

После анализа данного дерева были сформулированы некоторые свойства и ограничения, свойственные BFS-дереву.
Например, было доказано, что у некоторой вершины с номером $r$ в полном дереве самый правый ребенок имеет номер $rL + 1$.
Далее было доказано, что тогда $rL + 1$ является верхней оценкой на номер ребенка вершины $r$ в произвольном BFS-дереве.
Тогда, можно утверждать, что в произвольном BFS-дереве у вершины с номером $r$ дети могут иметь номера только в диапазоне от $r + 1$ до $rL + 1$.
Введение данных ограничений позволяет сократить число используемых в сведении переменных и сократить размер получающейся формулы.

По определению в любом BFS-дереве дети любой вершины $r$ имеют последовательные номера, а также верно, что их не более чем $L$.
Была проанализирована связь между вершинами расширенного префиксного дерева и состояниями ДКА.
Если в префиксном дереве существует путь длины $k$ от корня до некоторой вершины $t_{i}$, и вершина $t_{i}$ соответствует состоянию $d_{j}$ генерируемого автомата, то в автомате должен существовать путь длины не более чем $k$ от стартового состояния до состояния $d_{j}$.
Было разработано кодирование данных свойств на языке SAT.
Добавление соответствующих ограничений в формулу позволяет дополнительно сократить пространство поиска при решении задачи выполнимости.

\insection{\ref{sec:space:results}} приведены описание разработанного программного средства \texttt{DFA-Inductor-py}, предназначенного для генерации детерминированных конечных автоматов, описание реализации разработанных методов как частей данного программного средства, а также результаты экспериментальных исследований всех разработанных методов.

Во время работы над диссертацией на языке \emph{Python} было разработано программное средство \texttt{DFA-Inductor-py}~\cite{dfa-inductor-py}, предназначенное для генерации ДКА по заданным примерам поведения.
В состав средства входят различные модули, позволяющие решать задачу генерации ДКА по заданным примерам поведения, задачу генерации ДКА по избыточному набору примеров поведения и задачу генерации всех неизоморфных ДКА по заданным примерам поведения (данные методы описываются в следующих главах).
В средстве реализованы различные предикаты нарушения симметрии~--- как предложенные ранее другими авторами, так и разработанные в рамках настоящей диссертации.

С использованием реализованного программного средства были проведены две серии экспериментальных исследований.
Между собой сравнивались метод генерации ДКА по заданным примерам поведения с использованием оригинальных предикатов нарушения симметрии на основе BFS и аналогичный метод с использованием DFS-предикатов.
Поскольку метод \texttt{DFASAT}, использующий в качестве предикатов нарушения симметрии фиксирование нумерации некоторой большой клики графа несовместимости, лежит 

Имеющиеся в открытом доступе тестовые данные (наборы примеров поведения), например, с соревнований \emph{Abbadingo One DFA Learning Competition}~\cite{DBLP:conf/icgi/LangPP98} или \emph{StaMinA Competition}~\cite{DBLP:journals/ese/WalkinshawLDBD13}, разрабатывались под неточные алгоритмы, которые могут строить автоматы с сотнями состояний.
Существующие и предлагаемые в рамках настоящей диссертации точные методы пока не способны строить ДКА такого размера, поэтому тестовые данные генерировались случайно.
Результаты экспериментов представлены в таблице~\ref{syn:tab:DFS-results} и позволяют сделать вывод, что использование DFS-предикатов нарушения симметрии нецелесообразно, так как метод, их использующий, значительно проигрывает методу, использующему BFS-предикаты.
Однако можно заметить, что метод, использующий DFS-предикаты значительно выигрывает в производительности относительно метода \texttt{DFASAT}.
Тем не менее, исходя из результатов, было решено не продолжать развитие DFS-предикатов и сосредоточиться на улучшении предикатов, использующих алгоритм обхода графа в ширину.

\begin{table}[ht]
  \caption{Медианное время работы методов генерации ДКА по заданным примерам поведения с использованием BFS-предикатов нарушения симметрии, DFS-предикатов нарушения симметрии и метода \texttt{DFASAT} в секундах, посчитанное на 100 задачах для каждого набора параметров. Время работы методов было ограничено одним часом ($\text{TL} = 3600\,\, \text{секунд}$)}
  \centering
  \scalebox{0.95}{
    \begin{tabular}{cccccc}
      M & DFS     & & BFS    & & \texttt{DFASAT}\\
      \hline
      10 & 20,9   & & 20,5   & & 23,3  \\
      12 & 40,4   & & 37,6   & & 240,3 \\
      14 & 82,2   & & 62,4   & & ---   \\
      16 & 205,1  & & 114,1  & & ---   \\
      18 & 601,7  & & 181,9  & & ---   \\
      20 & 2501,6 & & 293,7  & & ---   \\
      22 & ---    & & 453,3  & & ---   \\
      24 & ---    & & 625,1  & & ---   \\
      26 & ---    & & 925,8  & & ---   \\
      28 & ---    & & 1314,4 & & ---   \\
      30 & ---    & & 1635,5 & & ---   \\
    \end{tabular}
  }
  \label{syn:tab:DFS-results}
\end{table}

Во втором экспериментальном исследовании сравнивались методы, использующие оригинальные BFS-предикаты (\texttt{DFA-Inductor}) и BFS-предикаты, разработанные в настоящей диссертации (\texttt{DFA-Inductor-py}).
Как и ранее, дополнительно в сравнение был включен метод \texttt{DFASAT}, и использовались случайно сгенерированные тестовые данные.
Результаты сравнения всех трех методов представлены на рисунке~\ref{syn:img:plots:cactus} и показывают, что метод \texttt{DFA-Inductor-py} способен за одно и то же время решить большее число экземпляров задачи генерации ДКА по заданным примерам поведения, чем метод \texttt{DFA-Inductor}~--- 731 решенная задача против 678 за 10 минут.
Также можно заметить, что метод \texttt{DFASAT} не способен составить конкуренции двум другим подходам.

На рисунке~\ref{syn:img:plots:scatter} представлено детальное сравнение методов \texttt{DFA-Inductor} и \texttt{DFA-Inductor-py}, где видно, что при решении подавляющего числа экземпляров задачи генерации ДКА, метод, предложенный в настоящей работе, показывает лучшие результаты.

\begin{figure}[ht]
  \centering
  \begin{subfigure}[b]{0,48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{img/lata19/plots/cactus}
    \caption{Сравнение методов \texttt{DFA-Inductor}, \texttt{DFA-Inductor-py} и \texttt{DFASAT}, показывающее число различных экземпляров задачи, решенных за определенное время}
    \label{syn:img:plots:cactus}
  \end{subfigure}%
  \;\;
  \begin{subfigure}[b]{0,48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{img/lata19/plots/scatter}
    \caption{Детальное сравнение методов \texttt{DFA-Inductor} и \texttt{DFA-Inductor-py}, сравнивающее их производительность в решении каждого экземпляра задачи}
    \label{syn:img:plots:scatter}
  \end{subfigure}
  \caption{Результаты сравнения метода, использующего оригинальные BFS-предикаты (\texttt{DFA-Inductor}), метода, использующего новые BFS-предикаты (\texttt{DFA-Inductor-py}), и \texttt{DFASAT}}
  \label{syn:img:plots}
\end{figure}

%------

В \textbf{\underline{третьей главе}} настоящей диссертации описываются разработка, реализация и экспериментальные исследования точного метода генерации детерминированных конечных автоматов по избыточному набору примеров поведения с использованием сведения к задаче выполнимости и подхода уточнения абстракции по контрпримерам.

\insection{\ref{sec:cegar:motivation}} приведено исследование границ применимости предложенных в предыдущих главах методов в зависимости от размера расширенного префиксного дерева. 
Размер булевой формулы, кодирующей задачу генерации ДКА, линейно зависит от размера префиксного дерева: $\mathcal{O}\left(N \times M^{2}\right)$ дизъюнктов, где $N$~--- размер префиксного дерева, а $M$~--- размер генерируемого ДКА.
Число используемых переменных в булевой формуле также линейно зависит от размера префиксного дерева~--- $\mathcal{O}\left(N \times M + M^{2}\right)$ переменных.
Таким образом, при неизменном генерируемом автомате, размер булевой формулы и число переменных может сильно меняться в зависимости от числа примеров поведения и их длины.
Программному средству для решения SAT при увеличении размера префиксного дерева становится все затратнее хранить формулу и работать с ней, а переменных для перебора становится все больше.
Это приводит к ситуации, когда один и тот же автомат может быть получен за секунды работы программного средства по небольшому числу примеров поведения небольшой длины и может быть не найден за часы и дни работы средства в случае \emph{избыточного} числа длинных примеров поведения.

Так как в случае детерминированных конечных автоматов ключевая информация о примере поведения~--- принимается данное слово автоматом или нет~--- содержится в последней вершине пути в расширенном префиксном дереве, соответствующего данному слову, то едва ли можно что-то сделать в случае длинных примеров поведения.
Однако в случае избыточного числа примеров поведения, можно взять только часть из них и построить тот же автомат быстрее.
Сложность состоит в способе выбора примеров поведения, так как можно исключить те примеры, которые являются необходимыми для генерации того ДКА, который является ответом на исходную задачу, и получить совершенно другой автомат.
В следующем разделе предлагается метод итеративного выбора только значимых примеров поведения из всего изначального множества, решающий данную проблему.

\insection{\ref{sec:cegar:cegar-algo}} приведено описание разработанного точного метода генерации ДКА по избыточному набору примеров поведения на основе сведения к SAT и с использованием подхода CEGAR. 
Как было указано ранее, обычно алгоритм уточнения абстракции по контрпримерам применяется для решения задач активного обучения. 
Задача генерации ДКА по заданным примерам поведения, в свою очередь, относится к классу задач пассивного обучения.
Однако, в настоящей диссертации предлагается метод, решающий задачу генерации ДКА по заданным примерам, использующий идеи подхода CEGAR.

Как и классический алгоритм CEGAR, предлагаемый метод итеративно уточняет модель, которая в настоящей диссертации является детерминированным конечным автоматом.
Изначально расширенное префиксное дерево не содержит вершин, но достраивается на каждом шаге.
На каждом шаге работы алгоритма предлагается с помощью сведения к SAT пытаться строить ДКА текущего размера по текущему префиксному дереву.
Если такого ДКА не существует, то как и раньше размер искомого автомата увеличивается на единицу и процесс поиска повторяется.
Если же такой автомат найден, он проверяется на соответствие оставшимся примерам поведения.
Если ДКА соответствует всем примерам поведения, то задача решена.
Иначе, среди тех примеров поведения, которым построенный автомат не соответствует, выбирается один или несколько контрпримеров, по которым достраивается префиксное дерево, строится новая булева формула и поиск продолжается.
Схема предложенного метода представлена на рисунке~\ref{syn:img:cegar-algo}.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.85]{img/ntv/cegar.pdf}
  \caption{Cхема точного метода генерации ДКА по избыточному набору примеров поведения на основе сведения к SAT и с использованием подхода CEGAR}
  \label{syn:img:cegar-algo}
\end{figure}

Необходимо заметить, что перезапускать программное средство для решения SAT при каждом достраивании префиксного дерева крайне неэффективно, так как при добавлении новых дизъюнктов в формулу, пространство поиска решения SAT только сужается, а, значит, нет необходимости начинать поиск выполняющей подстановки заново.
Можно использовать инкрементальные программные средства для решения SAT, которые после нахождения некоторой выполняющей подстановки переходят в режим ожидания новых дизъюнктов и затем продолжают поиск решения уже для новой уточненной формулы с того места, где остановились в прошлый раз.

\insection{\ref{sec:cegar:results}} приведены описание реализации разработанного метода как части программного средства \texttt{DFA-Inductor-py} и результаты экспериментальных исследований разработанного метода. 
Для проведения экспериментальных исследований снова использовались случайно сгенерированные тестовые данные.
Экспериментальные исследования показали, что при большом числе примеров поведения $S=\abs{S_{+}}+\abs{S_{-}} \geq 200 \times M$ метод на основе CEGAR работает как минимум в два раза быстрее метода, использующего сразу все примеры подедения.
Более того, выигрыш от использования CEGAR увеличивается с ростом числа примеров поведения.

%------

В \textbf{\underline{четвертой главе}} диссертации дается постановка задачи генерации всех неизоморфных детерминированных конечных автоматов, удовлетворяющих заданным примерам поведения, а затем описываются разработка, реализация и экспериментальные исследования двух методов, решающих поставленную задачу. 

\insection{\ref{sec:findall:problem}} приведена формальная постановка задачи генерации всех неизоморфных ДКА минимального размера, удовлетворяющих заданным примерам поведения.
Как уже было показано ранее, ДКА минимального размера является максимально точным обобщением имеющихся данных, выраженных с помощью примеров поведения.
Однако в случае, когда примеры поведения недостаточно хорошо описывают искомый автомат, может существовать несколько различных неизоморфных удовлетворяющих автоматов минимального размера.
В таком случае рациональным решением может быть построение всех таких автоматов для проведения дальнейшего анализа.
На рисунке~\ref{syn:img:find-all} приведены все неизоморфные ДКА минимального размера, построенные по заданным примерам поведения.
%
\begin{figure}[ht]
  \centering
  \ifafour
    \input{img/find-all-ex-tikz-compact-a4}
  \else
    \input{img/find-all-ex-tikz-compact-a5}
  \fi
  \caption{Все неизоморфные ДКА, соответствующие множествам примеров поведения $S_{+} = \left\{a, bb, aaaa\right\}$ и $S_{-}=\left\{aa, bab\right\}$}
  \label{syn:img:find-all}
\end{figure}

Ранее методы генерации всех различных ДКА с минимальным числом состояний по заданным примерам поведения не предлагались. 
Более того, без использования предикатов нарушения симметрии на основе BFS или DFS, разрешающих рассматривать для каждого класса эквивалентности по изоморфизму одного представителя вместо факториала, не представляется возможным эффективная генерация всех различных ДКА с помощью сведения к SAT.

\insection{\ref{sec:findall:SAT-based}} приведено описание метода генерации всех неизоморфных ДКА минимального размера с использованием сведения к SAT и предикатов нарушения симметрии.
Так как при использовании предикатов нарушения симметрии, построенных на основе кодирования алгоритма BFS (ровно как и на основе кодирования алгоритма DFS), может быть сгенерирован только ДКА, пронумерованный в порядке BFS (DFS), то достаточно заблокировать уже найденный автомат и исключить его (вместо со всеми изоморфными ему автоматами) из пространства поиска.
Из найденной выполняющей постановки построить автомат можно, используя только переменные переходов $y_{i,l,j}$ и переменные допуска $z_{i}$.
Тогда достаточно из всей найденной выполняющей подстановки запретить только значения этих переменных.
Если с помощью $\varphi\left(q\right)$ обозначить значение переменной $q$ в найденной подстановке $\varphi$ и определить множество $\mathcal{Y} = \{y_{i,l,j} | i,j \in \left[M\right] \wedge l \in \Sigma \wedge \varphi\left(y_{i,l,j}\right) = 1\}$, то \emph{блокирующий дизъюнкт} можно определить следующим образом:
\begin{equation*}
\bigwedge_{y \in \mathcal{Y}} \neg y \wedge \bigwedge_{i \in \left[M\right]}\neg \varphi\left(z_{i}\right).
\end{equation*}

Также как и в случае с методом, использующим подход CEGAR, при добавлении блокирующего дизъюнкта пространство поиска только сокращается, поэтому можно не перезапускать программное средство, а использовать его в инкрементальном режиме.

Еще одним важным применением предложенного метода является проверка того, что сгенерированный автомат является единственным существующим автоматом минимального размера, соответствующим заданным примерам поведения.
Единственность ДКА в таком случае говорит о том, что имеющиеся данные хорошо описывают найденный автомат.

\insection{\ref{sec:findall:results}} приведены описание реализации разработанных методов как частей программного средства \texttt{DFA-Inductor-py} и результаты экспериментальных исследований разработанных методов. 
Так как ранее не существовало эффективных методов решения задачи генерации всех различных ДКА по заданным примерам поведения, то в качестве базового для оценки производительности предложенного метода был разработан переборный алгоритм с возвратами, который ищет все различные ДКА по заданным примерам поведения без использования сторонних программных средств.

Результаты экспериментальных исследований представлены в таблице~\ref{syn:tab:find-all}.
Эксперименты проводились для трех различных групп экземпляров задачи генерации ДКА по заданным примерам поведения.
В первой группе число примеров поведения относительно размера генерируемого автомата имело соотношение $S = 5 \times M$,
во второй~--- $S = 10 \times M$, в третьей $S = 25 \times M$.
Столбец \enquote{$>$1} показывает процент экземпляров задачи, где существует больше одного неизоморфного автомата.

\begin{table}
  \centering
  \caption{Медианное время нахождения всех различных ДКА с помощью метода на основе сведения к SAT с перезапуском программного средства (REST), метода на основе сведения к SAT с использованием инкрементального программного средства (INC) и переборного метода с возвратами (BTR)}
  % нужно использовать десятичную запятую, а не точку
  \scalebox{0.8}{
    \begin{tabular}{ccccccccccccccc}
      \hline
      \multirow{2}{*}{$M$} & \multicolumn{4}{c}{$S = 5 \times M$}  & ~ & \multicolumn{4}{c}{$S = 10 \times M$} & ~ & \multicolumn{4}{c}{$S = 25 \times M$}\\\cline{2-5}\cline{7-10}\cline{12-15}
         & $>$1& REST  & INC    & BTR            & & $>$1& REST  & INC  & BTR             & & $>$1& REST & INC  & BTR            \\\hline
      5  & 53  & 2,3   & 2,0   & 0,8            & & 40  & 3,6   & 3,3  & 1,3             & & 17  & 4,1  & 3,4  & 1,5           \\ 
      6  & 56  & 2,8   & 2,4   & 2,1            & & 31  & 4,7   & 3,9  & 1,7             & & 27  & 5,4  & 4,3  & 1,7           \\ 
      7  & 87  & 3,9   & 2,5   & 4,1            & & 27  & 3,7   & 3,0  & 3,1             & & 13  & 7,4  & 6,7  & 2,5          \\ 
      8  & 80  & 4,6   & 3,7   & 87,2           & & 34  & 7,0   & 6,5  & 41,7            & & 16  & 10,1  & 8,9 & 11,6 \\ 
      9  & 91  & 7,6   & 3,9   & 475,1          & & 50  & 7,7   & 6,4  & 121,6           & & 10  & 13,8 & 13,0 & 61,4 \\ 
      10 & 89  & 15,7  & 5,3   & 2756,2         & & 47  & 8,6   & 7,0  & 974,7           & & 11  & 18,8 & 16,1 & 276,8 \\
      11 & 94  & 19,9  & 7,3   & ---            & & 63  & 18,5  & 13,8 & 3108,0          & & 9   & 24,5 & 21,9 & 1158,4 \\
      12 & 90  & 28,0  & 9,9   & ---            & & 49  & 22,3  & 16,7 & ---             & & 8   & 33,5 & 27,2 & 3289,1 \\
      13 & 92  & 185,5 & 18,1  & ---            & & 57  & 36,9  & 22,6 & ---             & & 12  & 62,0 & 51,4 & ---\\
      14 & 87  & 408,5 & 49,0  & ---            & & 71  & 85,1  & 41,8 & ---             & & 4   & 67,0 & 56,2 & ---\\
      15 & 95  & 571,1 & 174,1 & ---            & & 69  & 193,3 & 95,7 & ---             & & 6   & 29,2 & 26,2 & ---\\
      \hline
    \end{tabular}
  }
  \label{syn:tab:find-all}
\end{table}


Результаты экспериментов позволяют сделать несколько выводов:
\begin{enumerate}
  \item впервые успешно решена задача генерации всех различных ДКА минимального размера по заданным примерам поведения;
  \item оба метода, использующие сведение к SAT, значительно превосходят по производительности переборный метод;
  \item использование инкрементального программного средства, как и предполагалось, дает заметное преимущество относительно подхода с перезапуском программного средства, что объясняется сохранением промежуточного состояния инкрементальным программным средством после нахождения некоторого ДКА;
  \item чем больше примеров поведения дано для генерации ДКА, тем реже случается ситуация, когда существует несколько различных ДКА, соответствующих им.
\end{enumerate}

%------

%------

В \textbf{заключении} приведены основные результаты работы, которые заключаются в следующем:

\input{common/concl-ru}